<?xml version="1.0" encoding="utf-8"?>
<Symbols>
  <TemplateDecl Access="Public" Tags="x86, Windows">
    <Document>&lt;Document&gt;
  &lt;summary&gt;
Inherit from this class when you want to create a reflectable class. It should be used like this:
class YourClass : public Description&amp;lt;YourClass&amp;gt;
{
	...
};

After you have complete your type, use the following macros and functions to register your class into the global type table. Everything should be defined in vl::reflection::description namespaces.
Some of the predefined type has already been registered, if your types depend on these types, you should load those types by calling some or all of them:
&lt;links&gt;&lt;link cref="::vl::reflection::description::LoadPredefinedTypes()@s:vl.reflection.description.LoadPredefinedTypes()" /&gt;&lt;/links&gt;&lt;links&gt;&lt;link cref="::vl::reflection::description::LoadParsingTypes()@s:vl.reflection.description.LoadParsingTypes()" /&gt;&lt;/links&gt;&lt;links&gt;&lt;link cref="::vl::reflection::description::JsonLoadTypes()@s:vl.reflection.description.JsonLoadTypes()" /&gt;&lt;/links&gt;&lt;links&gt;&lt;link cref="::vl::reflection::description::XmlLoadTypes()@s:vl.reflection.description.XmlLoadTypes()" /&gt;&lt;/links&gt;

1) (in header files) Create a macro that contains all types that you want to register. Content in the list will become the registered type names, so it is strongly recommended to use the full name.
	#define MY_TYPELIST(F)\
		F(mynamespaces::MyClass1)\
		F(mynamespaces::MyClass2)\

2) (in header files) Connect type names and types:
	MY_TYPELIST(DECL_TYPE_INFO)

3) (in cpp files) Connect type names and types:
	MY_TYPELIST(IMPL_VL_TYPE_INFO)

4) (in cpp files) Register all members:
	
	#define _ ,

	a) enum:
		use BEGIN_ENUM_ITEM_MERGABLE instead of BEGIN_ENUM_ITEM if enum items are consider mergable using "|".
		if you want to provide a default value, use BEGIN_ENUM_ITEM_DEFAULT_VALUE(&amp;lt;your type&amp;gt;, &amp;lt;default value&amp;gt;)

		BEGIN_ENUM_ITEM(Season)
			ENUM_ITEM(Spring)
			ENUM_ITEM(Summer)
			ENUM_ITEM(Autumn)
			ENUM_ITEM(Winter)
		END_ENUM_ITEM(Season)

	b) enum class:
		use BEGIN_ENUM_ITEM_MERGABLE instead of BEGIN_ENUM_ITEM if enum items are consider mergable using "|".

		BEGIN_ENUM_ITEM(Season)
			ENUM_CLASS_ITEM(Spring)
			ENUM_CLASS_ITEM(Summer)
			ENUM_CLASS_ITEM(Autumn)
			ENUM_CLASS_ITEM(Winter)
		END_ENUM_ITEM(Season)

	c) struct (pure data structure):
		BEGIN_STRUCT_MEMBER(Point)
			STRUCT_MEMBER(x)
			STRUCT_MEMBER(y)
		END_STRUCT_MEMBER(Point)

	d) class:
		BEGIN_CLASS_MEMBER(MyClass)

			I) declare a base class (can have multiple base classes):
			CLASS_MEMBER_BASE(MyBaseClass)

			II) declare a field:
			CLASS_MEMBER_FIELD(myField)

			III) Empty constructor that results in a raw pointer:
			CLASS_MEMBER_CONSTRUCTIOR(MyClass*(), NO_PARAMETER)

			IV) Empty constructor that results in a smart pointer:
			CLASS_MEMBER_CONSTRUCTIOR(Ptr&amp;lt;MyClass&amp;gt;(), NO_PARAMETER)

			V) Constructor with arguments:
			CLASS_MEMBER_CONSTRUCTOR(Ptr&amp;lt;MyClass&amp;gt;(int, const WString&amp;amp;), {L"numberParameter" _ L"stringParameter"})

			VI) Inject a global function as a constructor
			CLASS_MEMBER_EXTERNALCTOR(Ptr&amp;lt;MyClass&amp;gt;(int, const WString&amp;amp;), {L"numberParameter" _ L"stringParameter"}, CreateMyClass)

			VII) Add unoverloaded functions
			CLASS_MEMBER_METHOD(MyFunction1, NO_PARAMETER)
			CLASS_MEMBER_METHOD(MyFunction2, {L"parameter1" _ L"parameter2"})

			VIII) Add unoverloaded function but give a different names
			CLASS_MEMBER_METHOD_RENAME(MyNewName1, MyFunction1, NO_PARAMETER)
			CLASS_MEMBER_METHOD_RENAME(MyNewName2, MyFunction2, {L"parameter1" _ L"parameter2"})

			IX) Add overloaded functions
			CLASS_MEMBER_METHOD_OVERLOAD(MyFunction3, NO_PARAMETER, int(MyClass::*)())
			CLASS_MEMBER_METHOD_OVERLOAD(MyFunction3, {L"parameter"}, int(MyClass::*)(int))
			CLASS_MEMBER_METHOD_OVERLOAD(MyFunction3, {L"parameter1" _ L"parameter2"}, int(MyClass::*)(int, const WString&amp;amp;))

			IX) Add overloaded functions but give different names
			CLASS_MEMBER_METHOD_OVERLOAD_RENAME(MyNewName3, MyFunction3, NO_PARAMETER, int(MyClass::*)())
			CLASS_MEMBER_METHOD_OVERLOAD_RENAME(MyNewName4, MyFunction3, {L"parameter"}, int(MyClass::*)(int))
			CLASS_MEMBER_METHOD_OVERLOAD_RENAME(MyNewName4, MyFunction3, {L"parameter1" _ L"parameter2"}, int(MyClass::*)(int, const WString&amp;amp;))

			X) Inject global functions as methods:
			CLASS_MEMBER_EXTERNALMETHOD(MyNewName5, {L"parameter"}, int(MyClass::*)(int), &amp;amp;AGlobalFunction)
			CLASS_MEMBER_EXTERNALMETHOD(MyNewName5, {L"parameter1" _ L"parameter2"}, int(MyClass::*)(int, const WString&amp;amp;), [](MyClass* a, int b, const WString&amp;amp; c){return 0;})

			XI) Add unoverloaded static functions
			CLASS_MEMBER_STATIC_METHOD(MyFunction4, NO_PARAMETER)
			CLASS_MEMBER_STATIC_METHOD(MyFunction5, {L"parameter1" _ L"parameter2"})

			XII) Add overloaded static functions
			CLASS_MEMBER_METHOD_OVERLOAD(MyFunction6, NO_PARAMETER, int(*)())
			CLASS_MEMBER_METHOD_OVERLOAD(MyFunction6, {L"parameter"}, int(*)(int))
			CLASS_MEMBER_METHOD_OVERLOAD(MyFunction6, {L"parameter1" _ L"parameter2"}, int(*)(int, const WString&amp;amp;))

			XIII) Inject global functions as static methods:
			CLASS_MEMBER_STATIC_EXTERNALMETHOD(MyNewName6, {L"parameter"}, int(*)(int), &amp;amp;AGlobalFunction2)
			CLASS_MEMBER_STATIC_EXTERNALMETHOD(MyNewName6, {L"parameter1" _ L"parameter2"}, int(*)(int, const WString&amp;amp;), [](int b, const WString&amp;amp; c){return 0;})

			XIV) Add a getter function as a property
			CLASS_MEMBER_PROPERTY_READONLY_FAST(X)
			which is short for
			CLASS_MEMBER_METHOD(GetX, NO_PARAMETER)
			CLASS_MEMBER_PROPERTY_READONLY(X, GetX)

			XV) Add a pair of getter and setter functions as a property
			CLASS_MEMBER_PROPERTY_FAST(X)
			which is short for
			CLASS_MEMBER_METHOD(GetX, NO_PARAMETER)
			CLASS_MEMBER_METHOD(SetX, {L"value"})
			CLASS_MEMBER_PROPERTY(X, GetX, SetX)

			XVI) Add a getter function as a property with a property changed event
			CLASS_MEMBER_EVENT(XChanged)
			CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(X)
			which is short for
			CLASS_MEMBER_EVENT(XChanged)
			CLASS_MEMBER_METHOD(GetX, NO_PARAMETER)
			CLASS_MEMBER_PROPERTY_EVENT_READONLY(X, GetX, XChanged)

			XVII) Add a pair of getter and setter functions as a property with a property changed event
			CLASS_MEMBER_EVENT(XChanged)
			CLASS_MEMBER_PROPERTY_EVENT_FAST(X)
			which is short for
			CLASS_MEMBER_EVENT(XChanged)
			CLASS_MEMBER_METHOD(GetX, NO_PARAMETER)
			CLASS_MEMBER_METHOD(SetX, {L"value"})
			CLASS_MEMBER_PROPERTY_EVENT(X, GetX, SetX, XChanged)

		END_CLASS_MEMBER(MyClass)

		If the code compiles, the class should look like this:
		class MyClass : public Description&amp;lt;MyClass&amp;gt;
		{
		public:
			MyClass();
			MyClass(int numberParameter, const WString&amp;amp; stringParameter);

			int MyFunction1();
			int MyFunction2(int parameter1, const WString&amp;amp; parameter2);
			int MyFunction3();
			int MyFunction3(int parameter);
			int MyFunction3(int parameter1, const WString&amp;amp; parameter2);

			static int MyFunction4();
			static int MyFunction5(int parameter1, const WString&amp;amp; parameter2);
			static int MyFunction6();
			static int MyFunction6(int parameter);
			static int MyFunction6(int parameter1, const WString&amp;amp; parameter2);

			Event&amp;lt;void()&amp;gt; XChanged;
			int GetX();
			void SetX(int value);
		};

		Ptr&amp;lt;MyClass&amp;gt; CreateMyClass(int numberParameter, const WString7 stringParameter);
		int GlobalFunction(MyClass* self, int parameter);

	e) interface:
		An interface is defined by
		I) Directly or indirectly inherits &lt;links&gt;&lt;link cref="::vl::reflection::IDescriptable@s:vl.reflection.IDescriptable" /&gt;&lt;/links&gt;
		II) The only registered constructor (if exists) should use Ptr&amp;lt;&lt;links&gt;&lt;link cref="::vl::reflection::description::IValueInterfaceProxy@s:vl.reflection.description.IValueInterfaceProxy" /&gt;&lt;/links&gt;&amp;gt; as a parameter

		Suppose you have an interface like this:
		class IMyInterface : public virtual IDescriptable, public Description&amp;lt;IMyInterface&amp;gt;
		{
		public:
			int GetX();
			void SetX(int value);
		};

		If you want this interface implementable by Workflow script, you should first add a proxy like this:
		class IMyInterfaceProxy : public &lt;links&gt;&lt;link cref="::vl::reflection::description::ValueInterfaceRoot@s:vl.reflection.description.ValueInterfaceRoot" /&gt;&lt;/links&gt;, public virtual IMyInterface
		{
		public:
			IMyInterfaceProxy(Ptr&amp;lt;IValueInterfaceProxy&amp;gt; proxy)
				:ValueInterfaceRoot(proxy)
			{
			}

			static Ptr&amp;lt;IMyInterface&amp;gt; Create(Ptr&amp;lt;IValueInterfaceProxy&amp;gt; proxy)
			{
				return new IMyInterfaceProxy(proxy);
			}

			int GetX()override
			{
				return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetX)
			}

			void SetX(int value)override
			{
				INVOKE_INTERFACE_PROXY(SetX, value)
			}
		};

		And then use this code to register the constructor:
		CLASS_MEMBER_EXTERNALCTOR(Ptr&amp;lt;IMyInterface&amp;gt;(Ptr&amp;lt;IValueInterfaceProxy&amp;gt;), {L"proxy"}, &amp;amp;IMyInterfaceProxy::Create)

		Everything else is the same as registering classes

	#undef _

5) (in cpp files) Create a type loader:
	class MyTypeLoader : public Object, public ITypeLoader
	{
	public:
		void Load(ITypeManager* manager)
		{
			MY_TYPELIST(ADD_TYPE_INFO)
		}

		void Unload(ITypeManager* manager)
		{
		}
	};

6) Load types when you think is a good timing using this code:
	vl::reflection::description::GetGlobalTypeManager()-&amp;gt;AddTypeLoader(new MyTypeLoader);

&lt;/summary&gt;
  &lt;typeparam name="T"&gt;Type of your created reflection class.&lt;/typeparam&gt;
&lt;/Document&gt;</Document>
    <TypeParameters>
      <TypeParameterDecl Access="Public" Name="T" Tags="x86, Windows" NameKey="::vl::reflection::T" OverloadKey="::vl::reflection::Description`1::T" />
    </TypeParameters>
    <Specialization />
    <Element>
      <ClassDecl Access="Public" Name="Description" Tags="x64, Windows;x86, Windows" NameKey="::vl::reflection::Description" OverloadKey="::vl::reflection::Description`1" ClassType="Class">
        <Children>
          <VarDecl Access="Protected" Name="associatedTypeDescriptor" Tags="x64, Windows;x86, Windows" NameKey="::vl::reflection::Description::associatedTypeDescriptor" OverloadKey="::vl::reflection::Description`1::associatedTypeDescriptor" Static="True">
            <Type>
              <DecorateTypeDecl Decoration="Pointer">
                <Element>
                  <SubTypeDecl ReferencingNameKey="::vl::reflection::description::ITypeDescriptor" Name="ITypeDescriptor">
                    <ReferencingOverloadKeys>
                      <Key Value="::vl::reflection::description::ITypeDescriptor@s:vl.reflection.description.ITypeDescriptor" />
                    </ReferencingOverloadKeys>
                    <Parent>
                      <RefTypeDecl ReferencingNameKey="::vl::reflection::description" Name="description">
                        <ReferencingOverloadKeys>
                          <Key Value="::vl::reflection::description@ns:vl.reflection.description" />
                        </ReferencingOverloadKeys>
                      </RefTypeDecl>
                    </Parent>
                  </SubTypeDecl>
                </Element>
              </DecorateTypeDecl>
            </Type>
          </VarDecl>
          <FuncDecl Access="Public" Name="Description" Tags="x64, Windows;x86, Windows" NameKey="::vl::reflection::Description::Description" OverloadKey="::vl::reflection::Description`1::Description()" Virtual="Normal" Function="Constructor">
            <Type>
              <FunctionTypeDecl CallingConvention="Default" Const="False">
                <ReturnType>
                  <RefTypeDecl Name="void" />
                </ReturnType>
                <Parameters />
              </FunctionTypeDecl>
            </Type>
          </FuncDecl>
          <FuncDecl Access="Public" Name="GetAssociatedTypeDescriptor" Tags="x64, Windows;x86, Windows" NameKey="::vl::reflection::Description::GetAssociatedTypeDescriptor" OverloadKey="::vl::reflection::Description`1::GetAssociatedTypeDescriptor()" Virtual="Static" Function="Function">
            <Type>
              <FunctionTypeDecl CallingConvention="Default" Const="False">
                <ReturnType>
                  <DecorateTypeDecl Decoration="Pointer">
                    <Element>
                      <SubTypeDecl ReferencingNameKey="::vl::reflection::description::ITypeDescriptor" Name="ITypeDescriptor">
                        <ReferencingOverloadKeys>
                          <Key Value="::vl::reflection::description::ITypeDescriptor@s:vl.reflection.description.ITypeDescriptor" />
                        </ReferencingOverloadKeys>
                        <Parent>
                          <RefTypeDecl ReferencingNameKey="::vl::reflection::description" Name="description">
                            <ReferencingOverloadKeys>
                              <Key Value="::vl::reflection::description@ns:vl.reflection.description" />
                            </ReferencingOverloadKeys>
                          </RefTypeDecl>
                        </Parent>
                      </SubTypeDecl>
                    </Element>
                  </DecorateTypeDecl>
                </ReturnType>
                <Parameters />
              </FunctionTypeDecl>
            </Type>
          </FuncDecl>
          <FuncDecl Access="Public" Name="SetAssociatedTypeDescroptor" Tags="x64, Windows;x86, Windows" NameKey="::vl::reflection::Description::SetAssociatedTypeDescroptor" OverloadKey="::vl::reflection::Description`1::SetAssociatedTypeDescroptor(* description::ITypeDescriptor)" Virtual="Static" Function="Function">
            <Type>
              <FunctionTypeDecl CallingConvention="Default" Const="False">
                <ReturnType>
                  <RefTypeDecl Name="void" />
                </ReturnType>
                <Parameters>
                  <VarDecl Access="Public" Name="typeDescroptor" Tags="x64, Windows;x86, Windows" NameKey="::vl::reflection::Description::SetAssociatedTypeDescroptor::typeDescroptor" OverloadKey="::vl::reflection::Description`1::SetAssociatedTypeDescroptor(* description::ITypeDescriptor)::typeDescroptor" Static="False">
                    <Type>
                      <DecorateTypeDecl Decoration="Pointer">
                        <Element>
                          <SubTypeDecl ReferencingNameKey="::vl::reflection::description::ITypeDescriptor" Name="ITypeDescriptor">
                            <ReferencingOverloadKeys>
                              <Key Value="::vl::reflection::description::ITypeDescriptor@s:vl.reflection.description.ITypeDescriptor" />
                            </ReferencingOverloadKeys>
                            <Parent>
                              <RefTypeDecl ReferencingNameKey="::vl::reflection::description" Name="description">
                                <ReferencingOverloadKeys>
                                  <Key Value="::vl::reflection::description@ns:vl.reflection.description" />
                                </ReferencingOverloadKeys>
                              </RefTypeDecl>
                            </Parent>
                          </SubTypeDecl>
                        </Element>
                      </DecorateTypeDecl>
                    </Type>
                  </VarDecl>
                </Parameters>
              </FunctionTypeDecl>
            </Type>
          </FuncDecl>
        </Children>
        <BaseTypes>
          <BaseTypeDecl Access="Public" Tags="x86, Windows">
            <Type>
              <RefTypeDecl ReferencingNameKey="::vl::reflection::DescriptableObject" Name="DescriptableObject">
                <ReferencingOverloadKeys>
                  <Key Value="::vl::reflection::DescriptableObject@s:vl.reflection.DescriptableObject" />
                </ReferencingOverloadKeys>
              </RefTypeDecl>
            </Type>
          </BaseTypeDecl>
        </BaseTypes>
      </ClassDecl>
    </Element>
  </TemplateDecl>
</Symbols>